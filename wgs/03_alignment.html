<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>03. Alignment (BWA + Samtools)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="../assets/css/style.css" />
  <style>
    pre { position: relative; background:#f8f9fa; padding:1rem; border-radius:6px; }
    .copy-btn { position:absolute; top:6px; right:6px; font-size:.8rem; }
    code { white-space: pre; }
    .note { color:#444; }
    .tip-card { border-left:4px solid #0d6efd; background:#f8fbff; }
    .tip-title { font-weight:700; color:#0d6efd; }
    .mini { font-size:.95rem; color:#555; }
  </style>
</head>
<body>
<div class="container py-5">
  <h1 class="mb-3">Step 03. Alignment (BWA + Samtools)</h1>
  <p class="lead">
    트리밍된 페어드엔드 FASTQ를 <b>BWA</b>로 레퍼런스에 정렬하고, <b>samtools</b>로 바로 <b>BAM</b>을 만들어 인덱싱까지 진행합니다.
    기본 쓰레드는 <b>20</b>을 사용합니다.
  </p>
  <hr/>

  <!-- A) Alignment 개요 -->
  <h3>A) Alignment란?</h3>
  <p class="note">
    NGS 리드를 <b>레퍼런스 게놈의 위치</b>에 배치하는 과정입니다. 보통 <i>seed-and-extend</i> 전략과
    <b>FM-index</b>(Burrows–Wheeler Transform 기반)를 사용해 빠르게 후보 위치를 찾고, 갭/불일치를 허용한 지역 정렬로
    최종 매핑을 확정합니다. 결과는 <b>SAM/BAM</b> 형식으로 저장되며, 각 리드에는 <b>MAPQ</b>(매핑 품질)과
    CIGAR(매칭/삽입/삭제 패턴) 같은 메타정보가 포함됩니다.
  </p>

  <!-- B) BWA 소개 -->
  <h3 class="mt-4">B) BWA란?</h3>
  <p class="note">
    <b>BWA(Burrows–Wheeler Aligner)</b>는 FM-index를 활용하는 빠른 단일/페어드엔드 리드 매퍼입니다.
    로우에러의 짧은~중간 길이 리드(일반적인 Illumina)에 최적화되어 있으며, 변이콜링 파이프라인(예: GATK)과의 호환성이 매우 좋습니다.
  </p>

  <!-- C) BWA 알고리즘 비교 -->
  <h3 class="mt-3">C) BWA 알고리즘 비교 (backtrack / SW / MEM)</h3>
  <div class="table-responsive mb-3">
    <table class="table table-sm table-bordered align-middle">
      <thead class="table-light">
        <tr>
          <th>알고리즘</th>
          <th>명령</th>
          <th>설계 배경 / 특징</th>
          <th>권장 리드 길이</th>
          <th>정렬 유형</th>
          <th>주요 용도/비고</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><b>BWA-backtrack</b></td>
          <td><code>bwa aln</code> → <code>bwa samse/sampe</code></td>
          <td>초기 세대 알고리즘. 짧은 리드에 최적화, 메모리 적음.</td>
          <td>~50–70 bp 이하</td>
          <td>주로 글로벌에 가까운 정렬</td>
          <td>레거시 데이터용. 현대 WGS에는 보통 비권장.</td>
        </tr>
        <tr>
          <td><b>BWA-SW</b></td>
          <td><code>bwa sw</code></td>
          <td>더 긴 리드(초창기 454/장문 리드) 대응. 스플릿/갭 허용.</td>
          <td>수백 bp 이상</td>
          <td>로컬 정렬(스미스-워터만 기반)</td>
          <td>역사적 이유로 존재. 현재는 사용 드묾.</td>
        </tr>
        <tr>
          <td><b>BWA-MEM</b></td>
          <td><code>bwa mem</code></td>
          <td>현대 표준. seed로 <i>Maximal Exact Match</i> 사용, 스플릿/소프트클리핑 지원, 정확도/속도 균형 우수.</td>
          <td>~70 bp – 1 Mb</td>
          <td>로컬 정렬 + 스플릿 정렬</td>
          <td><b>일반적인 WGS/WES에 권장</b>. GATK 등과 호환성 매우 좋음.</td>
        </tr>
      </tbody>
    </table>
  </div>
  <p class="mini">
    정리: 현대 Illumina WGS/Exome는 <b>BWA-MEM</b>이 사실상 표준입니다. backtrack/SW는 레거시/특수 케이스에 한정해 사용하세요.
  </p>

  <!-- D) samtools가 하는 일 -->
  <h3 class="mt-4">D) samtools는 무엇을 하나요?</h3>
  <ul>
    <li><code>samtools view</code>: SAM⇄BAM 변환, 태그/리전 필터 (<code>-bS</code> = BAM 출력, SAM 입력 허용).</li>
    <li><code>samtools sort</code>: (좌표 기준) 정렬된 BAM 생성. <code>-@</code>로 스레드 병렬화.</li>
    <li><code>samtools index</code>: <code>.bai</code> 인덱스 생성 → 특정 구간만 빠르게 접근.</li>
    <li><code>samtools flagstat</code>/<code>idxstats</code>: 매핑 요약 통계(QC) 확인.</li>
  </ul>
  <p class="note">
    우리가 쓰는 주요 옵션: <code>-@ &lt;threads&gt;</code>(스레드 병렬), <code>view -bS</code>(BAM 출력),
    <code>sort -o</code>(출력 파일 지정). 필요하면 <code>view -C -T REF</code>로 CRAM 저장도 가능해요(호환성 확인).
  </p>

  <!-- E) 왜 SAM을 저장하지 않나 -->
  <h3 class="mt-4">E) 왜 <code>bwa | samtools</code> 스트리밍으로 처리하나?</h3>
  <div class="card tip-card mb-3">
    <div class="card-body">
      <div class="tip-title mb-2">WGS에서는 SAM이 너무 큽니다</div>
      <p class="mb-2">
        WGS 한 샘플의 <b>SAM</b>은 수백 GB까지 커질 수 있습니다. 그래서 <b>bwa mem</b>의 출력(SAM 텍스트)을
        디스크에 저장하지 않고 <b>파이프(|)</b>로 즉시 <code>samtools view</code>와 <code>sort</code>에 넘겨
        <b>정렬된 BAM</b>을 바로 만듭니다.
      </p>
      <p class="mb-0">장점: 디스크 절약 · I/O 감소 · 파이프라인 간소화.</p>
    </div>
  </div>

  <!-- F) 단일 샘플 예제 -->
  <h3>F) 단일 샘플 예제 (스트리밍 → 정렬 BAM + 인덱스)</h3>
  <pre><button class="btn btn-sm btn-outline-primary copy-btn" onclick="copyCode(this)">Copy</button><code>
THREADS=20
REF="/home/kang/raw_data/gatk_bundle/v0/Homo_sapiens_assembly38.fasta"
R1="/home/kang/God_Nas/WGS_2nd/Trimmed_fastq/NP-21_R1.trimmed.fastq.gz"
R2="/home/kang/God_Nas/WGS_2nd/Trimmed_fastq/NP-21_R2.trimmed.fastq.gz"
OUT="/home/kang/God_Nas/WGS_2nd/aln"
SAMPLE="NP-21"
mkdir -p "${OUT}"

# Read Group(RG) — GATK 단계에서 필수/중요
RG="@RG\tID:${SAMPLE}\tSM:${SAMPLE}\tLB:${SAMPLE}\tPL:ILLUMINA"

# BWA-MEM 정렬 (SAM을 파일로 쓰지 않고 바로 BAM으로)
bwa mem \
  -t ${THREADS} \
  -M \            # Picard/GATK 호환(보조 정렬을 secondary로 마킹)
  -R "${RG}" \
  "${REF}" "${R1}" "${R2}" \
| samtools view  -@ ${THREADS} -bS - \
| samtools sort  -@ ${THREADS} -o "${OUT}/${SAMPLE}.sorted.bam" -

samtools index -@ ${THREADS} "${OUT}/${SAMPLE}.sorted.bam"

# (선택) QC 요약
samtools flagstat -@ ${THREADS} "${OUT}/${SAMPLE}.sorted.bam" > "${OUT}/${SAMPLE}.flagstat.txt"
samtools idxstats "${OUT}/${SAMPLE}.sorted.bam" > "${OUT}/${SAMPLE}.idxstats.txt"
</code></pre>

  <!-- G) 다중 샘플 배치 -->
  <h3 class="mt-4">G) 배치 실행 스크립트 (<code>run_alignment.sh</code>)</h3>
  <p class="note">트리밍 디렉토리의 <code>*_R1.trimmed.fastq.gz</code>를 기준으로 페어를 찾아 일괄 정렬합니다.</p>
  <pre><button class="btn btn-sm btn-outline-primary copy-btn" onclick="copyCode(this)">Copy</button><code>
#!/usr/bin/env bash
set -euo pipefail

THREADS=20
REF="/home/kang/raw_data/gatk_bundle/v0/Homo_sapiens_assembly38.fasta"
IN="/home/kang/God_Nas/WGS_2nd/Trimmed_fastq"
OUT="/home/kang/God_Nas/WGS_2nd/aln"
mkdir -p "${OUT}"

shopt -s nullglob
for R1 in "${IN}"/*_R1.trimmed.fastq.gz; do
  SAMPLE="$(basename "${R1}" _R1.trimmed.fastq.gz)"
  R2="${IN}/${SAMPLE}_R2.trimmed.fastq.gz"
  [[ -f "${R2}" ]] || { echo "[WARN] ${SAMPLE}: R2 not found — skip"; continue; }

  RG="@RG\tID:${SAMPLE}\tSM:${SAMPLE}\tLB:${SAMPLE}\tPL:ILLUMINA"

  echo "[ALIGN] ${SAMPLE} with BWA-MEM"
  bwa mem -t ${THREADS} -M -R "${RG}" "${REF}" "${R1}" "${R2}" \
    | samtools view -@ ${THREADS} -bS - \
    | samtools sort -@ ${THREADS} -o "${OUT}/${SAMPLE}.sorted.bam" -

  samtools index -@ ${THREADS} "${OUT}/${SAMPLE}.sorted.bam"
  samtools flagstat -@ ${THREADS} "${OUT}/${SAMPLE}.sorted.bam" > "${OUT}/${SAMPLE}.flagstat.txt"
done

echo "All done. BAMs in: ${OUT}"
</code></pre>

  <!-- H) 파일 형식 한눈에 -->
  <h3 class="mt-4">H) 파일 형식 한눈에</h3>
  <ul>
    <li><b>FASTQ</b>: 원시 리드(염기+품질). 보관/재분석을 위해 원본은 반드시 보존.</li>
    <li><b>SAM</b>: 텍스트 정렬 포맷(아주 큼). 사람이 보기 쉬우나 실무 저장에는 부적합.</li>
    <li><b>BAM</b>: SAM의 바이너리 압축. 정렬/인덱스/QC/변이콜링 표준 입력.</li>
    <li><b>CRAM</b>(선택): 레퍼런스 기반 압축으로 디스크 절약. 뷰어/툴 호환성 확인 필요.</li>
  </ul>

  <div class="mt-4 d-flex gap-2">
    <a class="btn btn-outline-secondary" href="02_trimming.html">← Back: Trimming</a>
    <a class="btn btn-primary" href="04_postproc.html">Next: Post-processing (Duplicates/BQSR) →</a>
  </div>
</div>

<script>
  function copyCode(btn){
    const code = btn.nextElementSibling.innerText;
    navigator.clipboard.writeText(code).then(()=>{
      const old = btn.innerText; btn.innerText = "Copied!";
      setTimeout(()=>{ btn.innerText = old; }, 1800);
    });
  }
</script>
</body>
</html>
